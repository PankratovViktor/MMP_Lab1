# -*- coding: utf-8 -*-
"""MMP_Lab1_Pankratov.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NbsoO7DyJO29ieSqFfV3W2RFaMA1fG_p
"""

import torch
import tqdm
from tqdm.notebook import trange
import numpy as np
import matplotlib.pyplot as plt
import sklearn
from sklearn import decomposition
from mpl_toolkits.mplot3d import Axes3D

x, y, z = np.indices((15, 15, 10))
cube1 = (x < 3) & (y < 3) & (z < 6) & (z > 2)
cube2 = (x < 3) & (4 < y) & (y < 8) & (z < 3)
cube3 = (x < 3) & (9 < y) & (y < 13) & (z < 6) & (z > 2)
cube4 = (4 < x) & (x < 8) & (9 < y) & (y < 13) & (z < 9) & (z > 5)
cube5 = (9 < x) & (x < 13) & (9 < y) & (y < 13) & (z < 6) & (z > 2)
cube6 = (9 < x) & (x < 13) & (4 < y) & (y < 8) & (z < 3)
cube7 = (9 < x) & (x < 13) & (y < 3) & (z < 6) & (z > 2)
cube8 = (4 < x) & (x < 8) & (y < 3) & (z < 9) & (z > 5)
voxels = cube1 | cube2 | cube3| cube4| cube5| cube6| cube7| cube8#| link

colors = np.empty(voxels.shape, dtype=object)
colors[cube1] = 'blue'
colors[cube2] = 'blue'
colors[cube3] = 'blue'
colors[cube4] = 'blue'
colors[cube5] = 'blue'
colors[cube6] = 'blue'
colors[cube7] = 'blue'
colors[cube8] = 'blue'

ax = plt.figure().add_subplot(projection='3d')
ax.voxels(voxels, facecolors=colors, edgecolor='k')

plt.show()

x, y, z = np.indices((15, 15, 10))
cube1 = (0 < x) & (x < 2) & (0 < y) & (y < 2) & (0 < z) & (z < 2)
cube2 = (4 < x) & (x < 8) & (4 < y) & (y < 8) & (z < 5) & (z > 1)
cube3 = (8 < x) & (x < 14) & (8 < y) & (y < 14) & (z < 8) & (z > 2)


voxels = cube1 | cube2 | cube3

colors = np.empty(voxels.shape, dtype=object)
colors[cube1] = 'blue'
colors[cube2] = 'blue'
colors[cube3] = 'blue'


ax = plt.figure().add_subplot(projection='3d')
ax.voxels(voxels, facecolors=colors, edgecolor='k')

plt.show()

im1  =np.zeros((15,15,15,15)) 
im2  =np.zeros((15,15,15,15)) 
im3  =np.zeros((15,15,15,15)) 
im4  =np.zeros((15,15,15,15)) 
im5  =np.zeros((15,15,15,15)) 
im6  =np.zeros((15,15,15,15)) 
im7  =np.zeros((15,15,15,15)) 
im8  =np.zeros((15,15,15,15)) 
for i in range(5):
  for j in range(5):
    for k in range(5):
      for l in range(5):
        im1[i,j,k,l+7] = 1
        im2[i,j+4,k+4,l+5] = 1
        im3[i,j+8,k,l+7] = 1
        im4[i+4,j+8,k +8,l+5] = 1
        im5[i+8,j+8,k+8,l+7] = 1
        im6[i+ 8,j+8,k + 8,l+5] = 1
        im7[i+8,j,k,l+7] = 1
        im8[i+4,j,k + 4,l+5] = 1
vidho = [[im1,im2,im3,im4,im5,im6,im7,im8] for i in range(10)]
vidhd = torch.tensor(vidho).reshape(80,15,15,15,15)

im1_1  =np.zeros((15,15,15,15)) 
im1_2  =np.zeros((15,15,15,15)) 
im1_3  =np.zeros((15,15,15,15)) 
im1_4  =np.zeros((15,15,15,15)) 
im1_5  =np.zeros((15,15,15,15)) 
im1_6  =np.zeros((15,15,15,15)) 
im1_7  =np.zeros((15,15,15,15)) 
im1_8  =np.zeros((15,15,15,15))
for p in range(8): 
  for i in range(p+1):
    for j in range(p+1):
      for k in range(p+1):
        for l in range(p+1):
          if(p == 0 ):
            im1_1[(i+p)%15,(j-p)%15,(k+2*p)%15,(l-3*p)%15] = 1
          if(p == 1 ):
            im1_2[(i+p)%15,(j-p)%15,(k+2*p)%15,(l-3*p)%15] = 1
          if(p == 2 ):
            im1_3[(i+p)%15,(j-p)%15,(k+2*p)%15,(l-3*p)%15] = 1
          if(p == 3 ):
            im1_4[(i+p)%15,(j-p)%15,(k+2*p)%15,(l-3*p)%15] = 1
          if(p == 4 ):
            im1_5[(i+p)%15,(j-p)%15,(k+2*p)%15,(l-3*p)%15] = 1
          if(p == 5 ):
            im1_6[(i+p)%15,(j-p)%15,(k+2*p)%15,(l-3*p)%15] = 1
          if(p == 6 ):
            im1_7[(i+p)%15,(j-p)%15,(k+2*p)%15,(l-3*p)%15] = 1
          if(p == 7 ):
            im1_8[(i+p)%15,(j-p)%15,(k+2*p)%15,(l-3*p)%15] = 1
vid1ho = [[im1_1,im1_2,im1_3,im1_4,im1_5,im1_6,im1_7,im1_8] for i in range(10)]
vid1hd = torch.tensor(vidho).reshape(80,15,15,15,15)

vid_nohd = np.zeros((9670,5)).astype(int)
for i in trange(9670):
  j = i % 8
  vid_nohd[i][0] = 0 + 5*(j > 2)+ 5*(j>3)*(j<7)
  vid_nohd[i][1] = 0 + 5*(j>0)*(j<6) + 5*(j>1)*(j<5)
  vid_nohd[i][2] = 5 + 5*((j+1)%2 == 0) - 10 * ((j+1)%4 == 0) 
  vid_nohd[i][3] = 7 + 7*((j+2)%2 == 0) - 10 * ((j+2)%4 == 0) 
  vid_nohd[i][4] = 1

vid1_nohd = np.zeros((9670,5)).astype(int)
c = 0
for i in range(5):
  for k in range(2*i + 1):
    for l in range(2*i + 1):
      for m in range(2*i + 1):
        for n in range(2*i + 1):
          vid1_nohd[c][0] = (i + k)%15
          vid1_nohd[c][1] = (5+ l - i)%15
          vid1_nohd[c][2] = (2*i + m)%15
          vid1_nohd[c][3] = (15+ n - 3*i)%15
          vid1_nohd[c][4] = i
          c = c + 1

vid2_hd = np.zeros((9670,7)).astype(int)
c = 0
for i in range(5):
  for k in range(2*i + 1):
    for l in range(2*i + 1):
      for m in range(2*i + 1):
        for n in range(2*i + 1):
          vid2_hd[c][0] = (i + k)%15
          vid2_hd[c][1] = (l - i)%15
          vid2_hd[c][2] = (2*i + m)%15
          vid2_hd[c][3] = (n - 3*i)%15
          vid2_hd[c][4] = i
          if (i == 0):
            vid2_hd[c][5] = (im1[vid2_hd[c][0],vid2_hd[c][0],vid2_hd[c][0],vid2_hd[c][0]] == 1)
            vid2_hd[c][6] = (im1_1[vid2_hd[c][0],vid2_hd[c][0],vid2_hd[c][0],vid2_hd[c][0]] == 1)
          if (i == 1):
            vid2_hd[c][5] = (im2[vid2_hd[c][0],vid2_hd[c][0],vid2_hd[c][0],vid2_hd[c][0]] == 1)
            vid2_hd[c][6] = (im1_2[vid2_hd[c][0],vid2_hd[c][0],vid2_hd[c][0],vid2_hd[c][0]] == 1)
          if (i == 2):
            vid2_hd[c][5] = (im3[vid2_hd[c][0],vid2_hd[c][0],vid2_hd[c][0],vid2_hd[c][0]] == 1)
            vid2_hd[c][6] = (im1_3[vid2_hd[c][0],vid2_hd[c][0],vid2_hd[c][0],vid2_hd[c][0]] == 1)
          if (i == 3):
            vid2_hd[c][5] = (im4[vid2_hd[c][0],vid2_hd[c][0],vid2_hd[c][0],vid2_hd[c][0]] == 1)
            vid2_hd[c][6] = (im1_4[vid2_hd[c][0],vid2_hd[c][0],vid2_hd[c][0],vid2_hd[c][0]] == 1)
          if (i == 4):
            vid2_hd[c][5] = (im5[vid2_hd[c][0],vid2_hd[c][0],vid2_hd[c][0],vid2_hd[c][0]] == 1)
            vid2_hd[c][6] = (im1_5[vid2_hd[c][0],vid2_hd[c][0],vid2_hd[c][0],vid2_hd[c][0]] == 1)
          c = c + 1

twodpca1 =  sklearn.decomposition.PCA( n_components = 3)
out = twodpca1.fit_transform(vid1_nohd[:,0:4],vid1_nohd[:,4])
print(twodpca1.explained_variance_ratio_)
print(twodpca1.components_)

x, y, z = np.indices((17, 17, 17))
outdraw = np.rint(out + [6.81,6.36,7.9]).astype(int)
cube1 = np.zeros((17,17,17)).astype(bool) 
for i in range(5**4):
  cube1[outdraw[i+1+3**4][1],outdraw[i+1+3**4][0],outdraw[i+1+3**4][2]] =1
colors = np.empty((17,17,17), dtype=object)
colors[cube1] = 'blue'
ax = plt.figure().add_subplot(projection='3d')
ax.voxels(cube1, facecolors=colors, edgecolor='k')

plt.show()

x, y, z = np.indices((17, 17, 17))
cube1 = np.zeros((17,17,17)).astype(bool) 
cube2 = np.zeros((17,17,17)).astype(bool) 
for i in range(9**4):
  cube1[outdraw[i+1+3**4+5**4+7**4][0],outdraw[i+1+3**4+5**4+7**4][1],outdraw[i+1+3**4+5**4+7**4][2]] =1
for i in range(17):
  for j in range(17):
    for k in range(17):
      if(outdraw1[i][j][k] == 1):
        cube2[i,j,k] = 1
      if(cube1[i,j,k]*cube2[i,j,k] == 1):
        cube1[i,j,k] = 0
        cube2[i,j,k] = 0
colors = np.empty((17,17,17), dtype=object)
colors[cube1] = 'blue'
colors[cube2] = 'green'
ax = plt.figure().add_subplot(projection='3d')
ax.voxels(cube1|cube2, facecolors=colors, edgecolor='k')
plt.show()